<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XSS</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="/css/section-page.css">
    <link rel="icon" href="/images/Introduction-to-XSS-module.png" type="images/x-icon">
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/tsparticles-slim@2.0.6/tsparticles.slim.bundle.min.js"></script>
    <script src="/javaScript/particles-config.js"></script>
    <main class="container">
        <nav>
            <div class="all">
                <div class="logo">
                    <a href="/html/index.html"><h1><span>Cyber</span>zone</h1></a>
                </div>
                <div class="choice"> <!--choice for desktop-->
                    <a href="/html/home.html">Home</a> <!--<i></i> tag "icon"-->
                    <a href="/html/paths.html">Paths</a>
                    <a href="/html/modules.html">Modules</a>
                    <a href="/php/downloads.php">Downloads</a>
                    <a href="https://cyberzone1.pythonanywhere.com/">Apps</a>
                    <a href="/html/ubuntu.html">Ubuntu</i></a>
                </div>
                <div class="register">
                    <a href="/html/sign-in.html" class="login"><button >Login</button></a>
                    <a href="/html/sign-up.html" class="signup"><button >sign up</button></a>
                </div>
            </div>
        </nav>
        <div class="banner-container">
            <div class="banner">
                <img class = "banner-icon" src="/images/Introduction-to-XSS-module.png">
                <div class = "banner-text" style="padding-left: 40px;">
                    <h1>XSS</h1>
                    <p>Explore in-depth the different types of XSS and their root causes.</p>
                </div>
            </div>
        </div>
        <div class = "content">
            <div class="tasks">
                <div class="task">
                    <div class="task-header task-header-correct-answer">
                        <div class="task-left">
                            <h4>Task 1</h4>
                            <i class="fa-solid fa-circle-check icon-correct-answer"></i>
                            <p>Introduction</p>
                        </div>
                    </div>
                    <div class="task-content">
                        <div class="task-text">
                            <h2>Cross-site Scripting (XSS) Vulnerabilities</h2>
                            <p>Cross-site scripting (XSS) remains one of the common vulnerabilities that threaten web applications to this day. XSS attacks rely on injecting a malicious script in a benign website to run on a user’s browser. In other words, XSS attacks exploit the user’s trust in the vulnerable web application, hence the damage.</p><br>
                            <h2>History and Evolution</h2>
                            <p>One of the earliest XSS vulnerabilities was recognized in 1999 and led to CERT advisory CA-2000-02. Over the past decades, various robust web security practices have become part of modern web application frameworks, protecting against many XSS vulnerabilities by default. On the other hand, the motives and sophistication of the attacks have also grown.</p><br>
                            <h2>Frequency and Ranking</h2>
                            <p>With the rise of web applications, it is no exaggeration that a few XSS vulnerabilities are discovered and exploited every month. In the OWASP Top 10, XSS was ranked seventh in 2017. In 2021’s report, XSS was grouped with other injection attacks and together are ranked third.</p><br>
                            <h2>Room Prerequisites</h2>
                            <p>It’s expected to have basic knowledge of HTTP and how websites work. If you don’t have this knowledge, we recommend completing the <a href="/html/how-the-web-work-module.html">How the Web Works</a> module first.</p>
                            <p>Finally, this room uses code snippets in PHP, JavaScript, Python, and C-Sharp. Knowledge of all these programming languages is not required. Instead, we explain the necessary code lines and focus on the causes and remedies of XSS vulnerabilities.</p>
                            <p>The purpose is to help us better understand why XSS came to exist and what makes it exploitable.</p><br>
                            <h2>Learning Objectives</h2>
                            <ul style="padding: 20px 0 0 55px;">
                            <li>Reflected XSS</li>
                            <li>Stored XSS</li>
                            <li>DOM-based XSS</li>
                            <li>How to protect against XSS</li>
                            </ul>
                        </div>
                        <div class="task-question">
                            <div class="question-title">
                                <h1>Answer The Question Below</h1>
                                <hr>
                            </div>
                            <div class="task-text">
                                <p>I completed the Intro to Cross-site Scripting room.</p>
                            </div>
                            <form class="question-submition" onsubmit="showCorrectAnswer(event)">
                                <input class="input" type="text" placeholder="Answer">
                                <input class="button" type="submit" value="Submit">
                            </form>
                        </div>
                    </div>
                </div>
                <div class="task">
                    <div class="task-header task-header-correct-answer">
                        <div class="task-left">
                            <h4>Task 2</h4>
                            <i class="fa-solid fa-circle-check icon-correct-answer"></i>
                            <p>Terminology and Types</p>
                        </div>
                    </div>
                    <div class="task-content">
                        <div class="task-text">
                            <h2>Understanding Cross-site Scripting (XSS)</h2>
                            <p>As already stated, XSS is a vulnerability that allows an attacker to inject malicious scripts into a web page viewed by another user. Consequently, they bypass the Same-Origin Policy (SOP); SOP is a security mechanism implemented in modern web browsers to prevent a malicious script on one web page from obtaining access to sensitive data on another page. SOP defines origin based on the protocol, hostname, and port. Consequently, a malicious ad cannot access data or manipulate the page or its functionality on another origin, such as an online shop or bank page. XSS dodges SOP as it is executing from the same origin.</p><br>
                            <h2>JavaScript for XSS</h2>
                            <p>Basic knowledge of JavaScript is pivotal for understanding XSS exploits and adapting them to your needs. Knowing that XSS is a client-side attack that takes place on the target’s web browser, we should try our attacks on a browser similar to that of the target. It is worth noting that different browsers process certain code snippets differently. In other words, one exploit code might work against Google Chrome but not against Mozilla Firefox or Safari.</p>
                            <p>Suppose you want to experiment with some JavaScript code in your browser. In that case, you need to open the Console found under Web Developer Tools on Firefox, Developer Tools on Google Chrome, and Web Inspector on Safari. Alternatively, use the respective shortcuts:</p>
                            <ul style="padding: 20px 0 0 55px;">
                            <li>On Firefox, press Ctrl + Shift + K</li>
                            <li>On Google Chrome, press Ctrl + Shift + J</li>
                            <li>On Safari, press Command + Option + J</li>
                            </ul><br>
                            <p>A web browser with the Console tab ready.</p>
                            <p>Let’s review and try some essential JavaScript functions:</p>
                            <ul style="padding: 20px 0 0 55px;">
                            <li>Alert: You can use the alert() function to display a JavaScript alert in a web browser. Try alert(1) or alert('XSS') (or alert("XSS")) to display an alert box with the number 1 or the text XSS.</li>
                            <li>Console log: Similarly, you can display a value in the browser’s JavaScript console using console.log(). Try the following two examples in the console log: console.log(1) and console.log("test text") to display a number or a text string.</li>
                            <li>Encoding: The JavaScript function btoa("string") encodes a string of binary data to create a base64-encoded ASCII string. This is useful to remove white space and special characters or encode other alphabets. The reverse function is atob("base64_string").</li>
                            </ul><br>
                            <p>Furthermore, you can experiment with displaying values, such as the document.cookie by using alert(document.cookie) for example.</p>
                            <p>A web browser with an alert displaying Hello World!</p>
                            <p>A web browser with the Console tab showing example JavaScript functions.</p><br>
                            <h2>Types of XSS</h2>
                            <p>To recap from the Intro to Cross-site Scripting room, there are three main types of XSS:</p>
                            <ul style="padding: 20px 0 0 55px;">
                            <li>Reflected XSS: This attack relies on the user-controlled input reflected to the user. For instance, if you search for a particular term and the resulting page displays the term you searched for (reflected), the attacker would try to embed a malicious script within the search term.</li>
                            <li>Stored XSS: This attack relies on the user input stored in the website’s database. For example, if users can write product reviews that are saved in a database (stored) and being displayed to other users, the attacker would try to insert a malicious script in their review so that it gets executed in the browsers of other users.</li>
                            <li>DOM-based XSS: This attack exploits vulnerabilities within the Document Object Model (DOM) to manipulate existing page elements without needing to be reflected or stored on the server. This vulnerability is the least common among the three.</li>
                            </ul>
                        </div>
                        <div class="task-question">
                            <div class="question-title">
                                <h1>Answer The Question Below</h1>
                                <hr>
                            </div>
                            <div class="task-text">
                                <p>Which XSS vulnerability relies on saving the malicious script?</p>
                            </div>
                            <form class="question-submition" onsubmit="showCorrectAnswer(event)">
                                <input class="input" type="text" placeholder="Answer">
                                <input class="button" type="submit" value="Submit">
                            </form>
                        </div>
                    </div>
                </div>
                <div class="task">
                    <div class="task-header task-header-correct-answer">
                        <div class="task-left">
                            <h4>Task 3</h4>
                            <i class="fa-solid fa-circle-check icon-correct-answer"></i>
                            <p>Causes and Implications</p>
                        </div>
                    </div>
                    <div class="task-content">
                        <div class="task-text">
                            <h2>The Nature of Cross-site Scripting (XSS)</h2>
                            <p>Cross-site scripting (XSS) is a web security vulnerability that allows an attacker to inject malicious scripts into a web page viewed by other users. As a result, the unsuspecting users end up running the unauthorized script in their browsers, although the website they are visiting is trusted to be benign. Therefore, XSS can be a severe threat because it exploits users’ trust in a site.</p><br>
                            <h2>Factors Enabling XSS Vulnerabilities</h2>
                            <p>There are many reasons why XSS vulnerabilities are still found in web apps. Below, we list a few of them.</p>
                            <ul style="padding: 20px 0 0 55px;">
                            <li>Insufficient input validation and sanitization</li>
                            <li>Lack of output encoding</li>
                            <li>Improper use of security headers</li>
                            <li>Framework and language vulnerabilities</li>
                            <li>Third-party libraries</li>
                            </ul><br>
                            <p>A malicious hacker writes a website comment that starts with a greeting and expresses that this is their first post. Furthermore, they include a URL that looks like it steals the user's cookie.</p><br>
                            <h2>Implications of XSS</h2>
                            <p>There are many implications of XSS. Below, we list a few of them.</p>
                            <ul style="padding: 20px 0 0 55px;">
                            <li>Session hijacking</li>
                            <li>Phishing and credential theft</li>
                            <li>Social engineering</li>
                            <li>Content manipulation and defacement</li>
                            <li>Data exfiltration</li>
                            <li>Malware installation</li>
                            </ul>
                        </div>
                        <div class="task-question">
                            <div class="question-title">
                                <h1>Answer The Question Below</h1>
                                <hr>
                            </div>
                            <div class="task-text">
                                <p>Based on the leading causes of XSS vulnerabilities, what operations should be performed on the user input?</p>
                            </div>
                            <form class="question-submition" onsubmit="showCorrectAnswer(event)">
                                <input class="input" type="text" placeholder="Answer">
                                <input class="button" type="submit" value="Submit">
                            </form>
                        </div>
                    </div>
                </div>
                <div class="task">
                    <div class="task-header task-header-correct-answer">
                        <div class="task-left">
                            <h4>Task 4</h4>
                            <i class="fa-solid fa-circle-check icon-correct-answer"></i>
                            <p>Reflected XSS</p>
                        </div>
                    </div>
                    <div class="task-content">
                        <div class="task-text">
                            <h2>Understanding Reflected Cross-site Scripting (XSS)</h2>
                            <p>Reflected XSS is a type of XSS vulnerability where a malicious script is reflected to the user’s browser, often via a crafted URL or form submission. Consider a search query containing many users wouldn’t be suspicious about such a URL, even if they look at it up close. If processed by a vulnerable web application, it will be executed within the context of the user’s browser.</p><br>
                            <p>In this innocuous example, it displays the cookie in an alert box. Obviously, an attacker wants to achieve more than just displaying the cookie as an alert to the user. However, for such an attack to be possible, we need a vulnerable application.</p><br>
                            <p>An attacker includes a malicious script in a URL and sends it to a target user. The user clicks on the URL and views the target website. Consequently, the malicious link executes, and something malicious takes place on their laptop.</p><br>
                            <h2>Vulnerable Web Application</h2>
                            <p>One simple reflected XSS vulnerability is when the user searches for some term, and the search string is included verbatim in the results page. This simple scenario provides an easy target for the attacker to exploit.</p><br>
                            <p>Although discovering such vulnerabilities is not always easy, fixing them is straightforward. User input such as should be sanitized or HTML-encoded to &lt;script&gt;alert('XSS')&lt;/script&gt;.</p><br>
                            <h2>Vulnerable Code Examples</h2>
                            <p>In the following subsections, we provide examples of vulnerable code in the following languages and frameworks:</p><br>
                            <h3>PHP</h3>
                            <p><strong>Vulnerable code:</strong></p>
                            <pre>&lt;?php
                            $search_query = $_GET['q'];
                            echo "&lt;p&gt;You searched for: $search_query&lt;/p&gt;";
                            ?&gt;</pre><br>
                            <p>If you are unfamiliar with PHP, $_GET is a PHP array containing values from the URL query string. Furthermore, $_GET['q'] refers to the query string parameter q. For example, in http://shop.thm/search.php?q=table, $_GET['q'] has the value table.</p><br>
                            <p>As you might have guessed, the vulnerability is caused by the search value displayed on the result page without sanitization. Therefore, an attacker can add a malicious script to the URL, knowing it would be executed. For example, as a proof of concept, the following URL can be tested: http://shop.thm/search.php?q=&lt;script&gt;alert(document.cookie)&lt;/script&gt; and if the site is vulnerable, an alert box will appear displaying the user’s cookie.</p><br>
                            <p><strong>Fixed code:</strong></p>
                            <pre>&lt;?php
                            $search_query = $_GET['q'];
                            $escaped_search_query = htmlspecialchars($search_query);
                            echo "&lt;p&gt;You searched for: $escaped_search_query&lt;/p&gt;";
                            ?&gt;</pre><br>
                            <p>The PHP function htmlspecialchars() converts special characters to HTML entities. The characters <, >, &, ", ' are replaced by default to prevent scripts in the input from executing.</p><br>
                            <h3>JavaScript (Node.js)</h3>
                            <p><strong>Vulnerable code:</strong></p>
                            <pre>const express = require('express');
                            const app = express();
                            
                            app.get('/search', function(req, res) {
                                var searchTerm = req.query.q;
                                res.send('You searched for: ' + searchTerm);
                            });
                            
                            app.listen(80);</pre><br>
                            <p>If you are unfamiliar with Node.js, the code snippet above uses Express, a popular web application framework for Node.js. The req.query.q will extract the value of q. For example, in http://shop.thm/search?q=table, req.query.q has the value table. Finally, the response is generated by appending the search term provided by the user to “You searched for:”.</p><br>
                            <p>Because the value is taken from the user and inserted in the response HTML without sanitization or escaping, it is easy to append a malicious query. As a proof of concept, we can test the following URL: http://shop.thm/search?q=&lt;script&gt;alert(document.cookie)&lt;/script&gt;, and if the site is vulnerable, an alert box will appear displaying the user’s cookie.</p><br>
                            <p><strong>Fixed code:</strong></p>
                            <pre>const express = require('express');
                            const sanitizeHtml = require('sanitize-html');
                            
                            const app = express();
                            
                            app.get('/search', function(req, res) {
                                const searchTerm = req.query.q;
                                const sanitizedSearchTerm = sanitizeHtml(searchTerm);
                                res.send('You searched for: ' + sanitizedSearchTerm);
                            });
                            
                            app.listen(80);</pre><br>
                            <p>The solution is achieved by using the sanitizeHtml() from the sanitize-html library. This function removes unsafe elements and attributes.</p><br>
                        </div>
                        <div class="task-question">
                            <div class="question-title">
                                <h1>Answer The Question Below</h1>
                                <hr>
                            </div>
                            <div class="task-text">
                                <p>Which one of the following characters do you expect to be encoded? ., ,, ;, &, or #?</p>
                            </div>
                            <form class="question-submition" onsubmit="showCorrectAnswer(event)">
                                <input class="input" type="text" placeholder="Answer">
                                <input class="button" type="submit" value="Submit">
                            </form>
                        </div>
                    </div>
                </div>
                <div class="task">
                    <div class="task-header task-header-correct-answer">
                        <div class="task-left">
                            <h4>Task 5</h4>
                            <i class="fa-solid fa-circle-check icon-correct-answer"></i>
                            <p>Vulnerable Web Application 1</p>
                        </div>
                    </div>
                    <div class="task-content">
                        <div class="task-text">
                            <h2>Exploring the Reflected XSS Vulnerability in copyparty</h2>
                            <p>Start the attached VM by clicking on the Start Machine button to finish this task.</p><br>
                            <p>The attached VM runs a vulnerable version of copyparty. The discovered reflected XSS vulnerability has the ID CVE-2023-38501, and its exploit is published <a href="#">here</a>.</p><br>
                            <p>The exploit code is ?k304=y%0D%0A%0D%0A%3Cimg+src%3Dcopyparty+onerror%3Dalert(1)%3E which is the URL encoding of:</p>
                            <pre>?k304=y &lt;img src=copyparty onerror=alert(1)&gt;</pre><br>
                            <p>The attached VM has the vulnerable server running at port 3923. You can reach the vulnerable server at <a href="#">http://MACHINE_IP:3923</a> via your AttackBox’s browser.</p>
                        </div>
                        <div class="task-question">
                            <div class="question-title">
                                <h1>Answer The Question Below</h1>
                                <hr>
                            </div>
                            <div class="task-text">
                                <p>What type of vulnerability is it?</p>
                            </div>
                            <form class="question-submition" onsubmit="showCorrectAnswer(event)">
                                <input class="input" type="text" placeholder="Answer">
                                <input class="button" type="submit" value="Submit">
                            </form>
                        </div>
                    </div>
                </div>
                <div class="task">
                    <div class="task-header task-header-correct-answer">
                        <div class="task-left">
                            <h4>Task 6</h4>
                            <i class="fa-solid fa-circle-check icon-correct-answer"></i>
                            <p>Stored XSS</p>
                        </div>
                    </div>
                    <div class="task-content">
                        <div class="task-text">
                            <h2>Understanding Stored XSS Vulnerabilities</h2>
                            <p>Stored XSS, or Persistent XSS, is a web application security vulnerability that occurs when the application stores user-supplied input and later embeds it in web pages served to other users without proper sanitization or escaping. Examples include web forum posts, product reviews, user comments, and other data stores. In other words, stored XSS takes place when user input is saved in a data store and later included in the web pages served to other users without adequate escaping.</p><br>
                            <p>The attacker posts a malicious script as part of their comment. A user views the comment. Consequently, something malicious takes place on their laptop.</p><br>
                            <p>Stored XSS begins with an attacker injecting a malicious script in an input field of a vulnerable web application. The vulnerability might lie in how the web application processes the data in the comment box, forum post, or profile information section. When other users access this stored content, the injected malicious script executes within their browsers. The script can perform a wide range of actions, from stealing session cookies to performing actions on behalf of the user without their consent.</p><br>
                            <p>There are many reasons for a web application to be vulnerable to stored XSS. Some of the best practices to prevent stored XSS vulnerabilities are:</p>
                            <ul style="padding: 20px 0 0 55px;">
                                <li>Validate and sanitize input: Define clear rules and enforce strict validation on all user-supplied data. For instance, only alphanumeric characters can be used in a username, and only integers can be allowed in age fields.</li><br>
                                <li>Use output escaping: When displaying user-supplied input within an HTML context, encode all HTML-specific characters, such as &lt;, &gt;, and &amp;.</li><br>
                                <li>Apply context-specific encoding: For instance, within a JavaScript context, we must use JavaScript encoding whenever we insert data within a JavaScript code. On the other hand, data placed in URLs must use relevant URL-encoding techniques, like percent-encoding. The purpose is to ensure that URLs remain valid while preventing script injection.</li><br>
                                <li>Practice defence in depth: Don’t rely on a single layer of defence; use server-side validation instead of solely relying on client-side validation.</li>
                            </ul><br>
                            <p>In the following examples, we list vulnerable code snippets in various languages. This exercise should be easy this time as the solutions resemble the solutions implemented earlier.</p><br>

                            <h2>PHP</h2>
                            <p><strong>Vulnerable Code</strong></p>
                            <pre>
                            <code>// Storing user comment
                            $comment = $_POST['comment'];
                            mysqli_query($conn, "INSERT INTO comments (comment) VALUES ('$comment')");

                            // Displaying user comment
                            $result = mysqli_query($conn, "SELECT comment FROM comments");
                            while ($row = mysqli_fetch_assoc($result)) {
                                echo $row['comment'];
                            }</code>
                            </pre>
                            <p>We are concerned with stored XSS, as SQL injection is outside the scope of this room. The main issue is that the comment is saved and later displayed, among the other comments, without sanitization.</p><br>
                            <p><strong>Fixed Code</strong></p>
                            <pre>
                            <code>// Storing user comment
                            $comment = mysqli_real_escape_string($conn, $_POST['comment']);
                            mysqli_query($conn, "INSERT INTO comments (comment) VALUES ('$comment')");

                            // Displaying user comment
                            $result = mysqli_query($conn, "SELECT comment FROM comments");
                            while ($row = mysqli_fetch_assoc($result)) {
                                $sanitizedComment = htmlspecialchars($row['comment']);
                                echo $sanitizedComment;
                            }</code>
                            </pre>
                            <p>Before displaying every comment on the screen, we pass it through the htmlspecialchars() function to ensure all special characters are converted to HTML entities. Consequently, any attempts for stored XSS won’t make it to the end user’s browser.</p><br>

                            <h2>JavaScript (Node.js)</h2>
                            <p><strong>Vulnerable Code</strong></p>
                            <pre>
                            <code>app.get('/comments', (req, res) => {
                            let html = '&lt;ul&gt;';
                            for (const comment of comments) {
                                html += `&lt;li&gt;${comment}&lt;/li&gt;`;
                            }
                            html += '&lt;/ul&gt;';
                            res.send(html);
                            });</code>
                            </pre>
                            <p>The main issue in the code above is that it reads the user’s input saved in comment (from the comments array) and is displayed as part of the HTML code. Consequently, when another user views this user’s comment as HTML, the browser will execute any scripts injected into it.</p><br>
                            <p><strong>Fixed Code</strong></p>
                            <pre>
                            <code>const sanitizeHtml = require('sanitize-html');

                            app.get('/comments', (req, res) => {
                            let html = '&lt;ul&gt;';
                            for (const comment of comments) {
                                const sanitizedComment = sanitizeHtml(comment);
                                html += `&lt;li&gt;${sanitizedComment}&lt;/li&gt;`;
                            }
                            html += '&lt;/ul&gt;';
                            res.send(html);
                            });</code>
                            </pre>
                            <p>Part of the solution is sanitizing the HTML before displaying it to the user. We can remove HTML elements outside the allowlist using the sanitizeHTML() function. In general, we expect to allow basic text formatting such as bold and italic (&lt;b&gt; and &lt;i&gt;), but we would remove potentially dangerous or unsafe elements such as &lt;script&gt; and &lt;onload&gt;. More information can be found on its official page.</p><br>

                            <h2>Python (Flask)</h2>
                            <p><strong>Vulnerable Code</strong></p>
                            <pre>
                            <code>from flask import Flask, request, render_template_string
                            from flask_sqlalchemy import SQLAlchemy

                            app = Flask(__name__)
                            app.config['SQLALCHEMY_DATABASE_URI'] =

                            'sqlite:///site.db'
                            db = SQLAlchemy(app)

                            class Comment(db.Model):
                                id = db.Column(db.Integer, primary_key=True)
                                content = db.Column(db.String, nullable=False)

                            @app.route('/comment', methods=['POST'])
                            def add_comment():
                                comment_content = request.form['comment']
                                comment = Comment(content=comment_content)
                                db.session.add(comment)
                                db.session.commit()
                                return 'Comment added!'

                            @app.route('/comments')
                            def show_comments():
                                comments = Comment.query.all()
                                return render_template_string(''.join(['&lt;div&gt;' + comment + '&lt;/div&gt;'<br> for comment in sanitized_comments]))</code>
                            </pre>
                            <p>The first issue is that the comment_content is set to the user’s form submission retrieved from request.form['comment'] without sanitization. This in itself lays the ground for stored XSS and SQL injection. Furthermore, when a user wants to view the comments, they are displayed without escaping, another perfect recipe for stored XSS.</p><br>
                            <p><strong>Fixed Code</strong></p>
                            <pre>
                            <code>from flask import Flask, request, render_template_string, escape
                            from flask_sqlalchemy import SQLAlchemy
                            from markupsafe import escape<br>

                            app = Flask(__name__)<br>
                            app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///site.db'<br>
                            db = SQLAlchemy(app)<br>

                            class Comment(db.Model):<br>
                                id = db.Column(db.Integer, primary_key=True)<br>
                                content = db.Column(db.String, nullable=False)<br>

                            @app.route('/comment', methods=['POST'])<br>
                            def add_comment():<br>
                                comment_content = request.form['comment']<br>
                                comment = Comment(content=comment_content)<br>
                                db.session.add(comment)<br>
                                db.session.commit()<br>
                                return 'Comment added!'<br>

                            @app.route('/comments')<br>
                            def show_comments():<br>
                                comments = Comment.query.all()<br>
                                sanitized_comments = [escape(c.content) for c in comments]<br>
                                return render_template_string(''.join(['&lt;div&gt;' + comment + '&lt;/div&gt;'<br> for comment in sanitized_comments]))</code>
                            </pre>
                            <p>We used the escape() function to ensure that any special characters in the user-submitted comment are replaced with HTML entities. As you would expect, the characters &amp;, &lt;, &gt;, ', and " are converted to HTML entities (&amp;amp;, &amp;lt;, &amp;gt;, &amp;#39;, and &amp;quot;). We made two changes:</p><br>

                            <h2>C# (ASP.NET)</h2>
                            <p><strong>Vulnerable Code</strong></p>
                            <pre>
                            <code>public void SaveComment(string userComment)
                            {
                                var command = new SqlCommand("INSERT INTO Comments (Comment)<br> VALUES ('" + userComment + "')", connection);
                                // Execute the command
                            }

                            public void DisplayComments()
                            {
                                var reader = new SqlCommand("SELECT Comment FROM Comments",<br> connection).ExecuteReader();
                                while (reader.Read())
                                {
                                    Response.Write(reader["Comment"].ToString());
                                }
                                // Execute the command
                            }</code>
                            </pre>
                            <p>One of the vulnerabilities we observe in the code above is stored XSS. The system stores whatever comment the user inputs without any changes and later displays it to other users. Another vulnerability outside the scope of this room is SQL injection.</p><br>
                            <p><strong>Fixed Code</strong></p>
                            <pre>
                            <code>using System.Web;

                            public void SaveComment(string userComment)
                            {
                                var command = new SqlCommand("INSERT INTO<br> Comments (Comment) VALUES (@comment)", connection);
                                command.Parameters.AddWithValue("@comment", userComment);
                            }

                            public void DisplayComments()
                            {
                                var reader = new SqlCommand("SELECT Comment FROM Comments",<br> connection).ExecuteReader();
                                while (reader.Read())
                                {
                                    var comment = reader["Comment"].ToString();
                                    var sanitizedComment = HttpUtility.HtmlEncode(comment);
                                    Response.Write(sanitizedComment);
                                }
                                reader.Close();
                            }</code>
                            </pre>
                            <p>With a few changes, the code’s security has improved. Stored-XSS is fixed by using the HttpUtility.HtmlEncode() method before displaying the userComment as part of a web page. (If you are curious, the SQL injection vulnerability is fixed by using parametrized SQL queries with values passed separately instead of building the SQL query via string concatenation. This can be achieved using the Parameters.AddWithValue() method in the SqlCommand objects.</p><br>
                        </div>
                        <div class="task-question">
                            <div class="question-title">
                                <h1>Answer The Question Below</h1>
                                <hr>
                            </div>
                            <div class="task-text">
                                <p>What is the name of the JavaScript function we used to sanitize the user input before saving it?</p>
                            </div>
                            <form class="question-submition" onsubmit="showCorrectAnswer(event)">
                                <input class="input" type="text" placeholder="Answer">
                                <input class="button" type="submit" value="Submit">
                            </form>
                        </div>
                    </div>
                </div>
                <div class="task">
                    <div class="task-header task-header-correct-answer">
                        <div class="task-left">
                            <h4>Task 7</h4>
                            <i class="fa-solid fa-circle-check icon-correct-answer"></i>
                            <p>Vulnerable Web Application 2</p>
                        </div>
                    </div>
                    <div class="task-content">
                        <div class="task-text">
                            <h2>Start the attached VM</h2>
                            <p>Start the attached VM by clicking on the Start Machine button to finish this task.</p>
                            <br>
                            <h2>The Vulnerable Hospital Management System</h2>
                            <p>The attached VM runs the vulnerable project Hospital Management System. The project was uploaded a few years ago and was never updated since then. It is fully functional. Unfortunately, a stored XSS vulnerability was discovered and tagged as CVE-2021-38757 and an exploit was published, but the application has not been patched till the time of writing.</p>
                            <br>
                            <h2>Exploiting the Vulnerability</h2>
                            <p>To exploit the vulnerability, the attacker only needs to click on “Contact”, and fill in the name, email, phone number, and submit the payload in the message field. Something simple such as <code>&lt;script&gt;alert("Simple XSS")&lt;/script&gt;</code> would still work.</p>
                            <br>
                            <h2>Logging in as Receptionist</h2>
                            <p>Any message sent via the Contact page appears to the Receptionist when they log in. To log in as the Receptionist via the corresponding tab, use the following credentials:</p>
                            <ul style="padding: 20px 0 0 55px;">
                            <li>Username: admin</li>
                            <li>Password: admin123</li>
                            </ul>
                            <br>
                            <h2>Accessing the Vulnerable Server</h2>
                            <p>The attached VM has its vulnerable server running at port 80. You can access it at <a href="http://MACHINE_IP">http://MACHINE_IP</a>.</p>
                            <br>
                            <h2>The Vulnerable Code</h2>
                            <p>The vulnerability lies in the contact.php. Although the code works well, it is not secure. As we can see in the listing below, the user’s submitted message is saved unsanitized in the database table:</p>
                            <pre><code>&lt;?php 
                            $con=mysqli_connect("localhost","root","","myhmsdb");
                            if(isset($_POST['btnSubmit']))
                            {
                                $name = $_POST['txtName'];
                                $email = $_POST['txtEmail'];
                                $contact = $_POST['txtPhone'];
                                $message = $_POST['txtMsg'];

                                $query="insert into contact(name,email,contact,message)<br> values('$name','$email','$contact','$message');";

                            //...
                            }
                            ?&gt;
                            </code></pre>
                        </div>
                        <div class="task-question">
                            <div class="question-title">
                                <h1>Answer The Question Below</h1>
                                <hr>
                            </div>
                            <div class="task-text">
                                <p>What type of vulnerability is it?</p>
                            </div>
                            <form class="question-submition" onsubmit="showCorrectAnswer(event)">
                                <input class="input" type="text" placeholder="Answer">
                                <input class="button" type="submit" value="Submit">
                            </form>
                        </div>
                    </div>
                </div>
                <div class="task">
                    <div class="task-header task-header-correct-answer">
                        <div class="task-left">
                            <h4>Task 8</h4>
                            <i class="fa-solid fa-circle-check icon-correct-answer"></i>
                            <p>DOM-Based XSS</p>
                        </div>
                    </div>
                    <div class="task-content">
                        <div class="task-text">
                            <h2>Introduction to DOM-based XSS</h2>
                            <p>If you check any updated Security Advisories, it is easy to find new reflected and stored XSS vulnerabilities discovered monthly. However, the same is not true for DOM-based XSS, which is getting scarce nowadays. The reason is that DOM-based XSS is completely browser-based and does not need to go to the server and back to the client. At one point, a proof of concept example of DOM-based XSS could be created using a static HTML page; however, with the improved inherent security of web browsers, DOM-based XSS has become extremely difficult.</p>
                            <br>
                            <h2>Understanding Document Object Model (DOM)</h2>
                            <p>Before we dive into DOM-based XSS, let’s review what Document Object Model (DOM) is. The DOM is a programming interface representing a web document as a tree. The DOM makes it possible to programmatically access and manipulate the different parts of a website using JavaScript. Let’s consider a practical example.</p>
                            <br>
                            <h2>Example of DOM Tree</h2>
                            <p>Consider the HTML code of example.com in the screenshot below (as fetched on the first of February 2024). We opened the Web Developer Tools using the Firefox web browser and checked the Inspector tab.</p>
                            <br>
                            <h2>Accessing and Manipulating DOM</h2>
                            <p>We can view the DOM tree using the web browser’s built-in Web Developer’s Tools. For example, press Ctrl + Shift + I on Firefox and check the Inspector tab.</p>
                            <p>Alternatively, we can access the JavaScript console, as mentioned in Task 2. Using JavaScript, you can manipulate the DOM tree. For example, you can create a new element using document.createElement() and add a child to any element using element.append(). Here is an example from MDN documentation.</p>
                            <br>
                            <h2>Vulnerable Web Applications</h2>
                            <p>DOM-based XSS vulnerabilities take place within the browser. They don’t need to go to the server and return to the client’s web browser. In other words, the attacker will try to exploit this situation by injecting a malicious script, for example, into the URL, and it will be executed on the client’s side without any role for the server in this. We will present an elementary and minimal static site without relying on the back-end code to demonstrate this concept.</p>
                            <br>
                            <h2>Example of Vulnerable “Static” Site</h2>
                            <p>Let’s consider the following basic example. It is too simple that it is unrealistic; however, it is enough to demonstrate the DOM-based XSS.</p>
                            <br>
                            <h2>Fixed “Static” Site</h2>
                            <p>One way to fix this page is by avoiding adding user input directly with document.write(). Instead, we first escaped the user input using encodeURIComponent() and then added it to textContent.</p>
                        </div>
                        <div class="task-question">
                            <div class="question-title">
                                <h1>Answer The Question Below</h1>
                                <hr>
                            </div>
                            <div class="task-text">
                                <p>DOM-based XSS is reflected via the server. (Yea/Nay)</p>
                            </div>
                            <form class="question-submition" onsubmit="showCorrectAnswer(event)">
                                <input class="input" type="text" placeholder="Answer">
                                <input class="button" type="submit" value="Submit">
                            </form>
                        </div>
                    </div>
                </div>
                <div class="task">
                    <div class="task-header task-header-correct-answer">
                        <div class="task-left">
                            <h4>Task 9</h4>
                            <i class="fa-solid fa-circle-check icon-correct-answer"></i>
                            <p>Context and Evasion</p>
                        </div>
                    </div>
                    <div class="task-content">
                        <div class="task-text">
                            <h2>Context</h2>
                            <p>The injected payload will most likely find its way within one of the following:</p>
                            <ul style="padding: 20px 0 0 55px;">
                                <li>Between HTML tags</li>
                                <li>Within HTML tags</li>
                                <li>Inside JavaScript</li>
                            </ul>
                            <br>
                            <p>When XSS happens between HTML tags, the attacker can run <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>.</p>
                            <p>However, when the injection is within an HTML tag, we need to end the HTML tag to give the script a turn to load. Consequently, we might adapt our payload to <code>&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code> or <code>"&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code> or something similar that would fit in the context.</p>
                            <p>We might need to terminate the script to run the injected one if we can inject our XSS within an existing JavaScript. For instance, we can start with <code>&lt;/script&gt;</code> to end the script and continue from there. If your code is within a JavaScript string, you can close the string with <code>'</code>, complete the command with a semicolon, execute your command, and comment out the rest of the line with <code>//</code>. You can try something like this <code>';alert(document.cookie)//</code>.</p>
                            <p>This example should give you some ideas to escape the context you start from. Generally speaking, being aware of the context where your XXS payload is executing is very important for the successful execution of the payload.</p>
                            <br>
                            <h2>Evasion</h2>
                            <p>Various repositories can be consulted to build your custom XSS payload. This gives you plenty of room for experimentation. One such list is the XSS Payload List.</p>
                            <p>However, sometimes, there are filters blocking XSS payloads. If there is a limitation based on the payload length, then Tiny XSS Payloads can be a great starting point to bypass length restrictions.</p>
                            <p>If XSS payloads are blocked based on specific blocklists, there are various tricks for evasion. For instance, a horizontal tab, a new line, or a carriage return can break up the payload and evade the detection engines.</p>
                            <ul style="padding: 20px 0 0 55px;">
                                <li>Horizontal tab (TAB) is 9 in hexadecimal representation</li>
                                <li>New line (LF) is A in hexadecimal representation</li>
                                <li>Carriage return (CR) is D in hexadecimal representation</li>
                            </ul>
                            <p>Consequently, based on the XSS Filter Evasion Cheat Sheet, we can break up the payload <code>&lt;IMG SRC="javascript:alert('XSS');"&gt;</code> in various ways:</p>
                            <ul style="padding: 20px 0 0 55px;">
                                <li><code>&lt;IMG SRC="jav&#x09;ascript:alert('XSS');"&gt;</code></li>
                                <li><code>&lt;IMG SRC="jav&#x0A;ascript:alert('XSS');"&gt;</code></li>
                                <li><code>&lt;IMG SRC="jav&#x0D;ascript:alert('XSS');"&gt;</code></li>
                            </ul>
                            <p>There are hundreds of evasion techniques; the choice would depend on the target security and require trial and error before achieving a successful outcome.</p>
                        </div>
                        <div class="task-question">
                            <div class="question-title">
                                <h1>Answer The Question Below</h1>
                                <hr>
                            </div>
                            <div class="task-text">
                                <p>Which character does &#x09 represent?</p>
                            </div>
                            <form class="question-submition" onsubmit="showCorrectAnswer(event)">
                                <input class="input" type="text" placeholder="Answer">
                                <input class="button" type="submit" value="Submit">
                            </form>
                        </div>
                    </div>
                </div>
                <div class="task">
                    <div class="task-header task-header-correct-answer">
                        <div class="task-left">
                            <h4>Task 10</h4>
                            <i class="fa-solid fa-circle-check icon-correct-answer"></i>
                            <p>Conclusion</p>
                        </div>
                    </div>
                    <div class="task-content">
                        <div class="task-text">
                            <h2>The Purpose of This Room</h2>
                            <p>The purpose of this room is to give you a more in-depth understanding of the underlying workings of XSS scripts.<br> We covered the causes and many remedies for XSS scripting. Understanding what is happening behind the scenes<br> should give you an edge in exploring existing exploits and adapting them to your needs.</p>
                        </div>
                        <div class="task-question">
                            <div class="question-title">
                                <h1>Answer The Question Below</h1>
                                <hr>
                            </div>
                            <div class="task-text">
                                <p>This room used a fictional static site to demonstrate one of the XSS vulnerabilities. Which XSS type was that?</p>
                            </div>
                            <form class="question-submition" onsubmit="showCorrectAnswer(event)">
                                <input class="input" type="text" placeholder="Answer">
                                <input class="button" type="submit" value="Submit">
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <footer>
            <div class="main">
                <div class="tag">
                    <h1>Core Team</h1>
                    <div class="social_link">
                        <a href="#"><i class="fa-brands fa-facebook-f"></i></a>
                        <a href="#"><i class="fa-brands fa-twitter"></i></a>
                        <a href="#"><i class="fa-brands fa-instagram"></i></a>
                        <a href="#"><i class="fa-brands fa-linkedin-in"></i></a>
                    </div>
                    <div class="copyright">
                        <p>Copyright © 2024 <a href="#">Core</a> All rights reserved</p>
                    </div>
                </div>
            </div>
        </footer>
    </main>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            var headers = document.querySelectorAll('.task-header');
        
            headers.forEach(function(header) {
                header.addEventListener('click', function() {
                    // Find the current task's content
                    var taskContent = this.nextElementSibling;
        
                    // Hide all task contents
                    document.querySelectorAll('.task-content').forEach(function(content) {
                        if (content !== taskContent) {
                            content.style.display = 'none'; // Hide other task contents
                        }
                    });
        
                    // Toggle the visibility of the current task's content
                    taskContent.style.display = taskContent.style.display === 'none' || taskContent.style.display === '' ? 'block' : 'none';
                });
            });
        
            document.querySelectorAll('.question-submition').forEach(function(form) {
                form.addEventListener('submit', function(event) {
                    event.preventDefault(); // Prevent the form from submitting normally
                    
                    var task = this.closest('.task');
                    var icon = task.querySelector('.icon-correct-answer');
                    var header = task.querySelector('.task-header-correct-answer');
                    
                    icon.style.display = 'block'; // Show the icon
                    header.style.borderLeftColor = 'rgb(32, 199, 32)'; // Change the border color
                });
            });
        });
        </script>
         <script>
            const navBar = document.querySelector('nav');
    
            function toggleBlurOnScroll() {
                if (window.scrollY > 50) {
                    navBar.classList.add('blurred');
                } else {
                    navBar.classList.remove('blurred');
                }
            }
    
            window.addEventListener('scroll', toggleBlurOnScroll);
        </script>
        <script src="/javaScript/progress.js"></script>
</body>
</html>